{
  "author": {
    "name": "Michael Bridgen",
    "email": "mikeb@squaremobius.net"
  },
  "name": "bitsyntax",
  "description": "Pattern-matching on byte buffers",
  "version": "0.0.1",
  "repository": {
    "type": "git",
    "url": "git://github.com/squaremo/bitsyntax-js.git"
  },
  "main": "./index",
  "scripts": {
    "test": "make test"
  },
  "engines": {
    "node": ">0.4"
  },
  "dependencies": {},
  "devDependencies": {},
  "readme": "# Byte-wise matching for Node.JS\n\nGives a compact syntax for parsing binary data, derived from [Erlang's\nbit syntax](http://www.erlang.org/doc/programming_examples/bit_syntax.html#id64858).\n\n    var bitsyntax = require('bitsyntax');\n    var pattern = bitsyntax.compile('len:8/integer, string:len/binary');\n    var bound = pattern(new Buffer([4, 0x41, 0x42, 0x43, 0x44]));\n    bound.string\n    // => <Buffer 41 42 43 44>\n\nA typical use of this is parsing byte streams from sockets. For\nexample, size-prefixed frames:\n\n    var framePattern = bitsyntax.compile('len:32/integer, frame:len/binary, rest/binary');\n    socket.on('data', function process(data) {\n      var m;\n      if (m = framePattern(data)) {\n        emit('frame', m.frame);\n        process(m.rest);\n      }\n      else {\n        stashForNextData(data);\n      }\n    });\n\n## API\n\n### `compile`\n\nCompiles a pattern given as a string to a function that will return\neither a map of bindings, or `false`, given a buffer and optionally an\nenvironment. The environment contains values for the bound variables\nin the pattern (if there are any).\n\n    var p = bitsyntax.compile('header:headerSize/binary, rest/binary');\n    var b = p(new Buffer([1, 2, 3, 4, 5]), {headerSize: 3});\n    b.header\n    // => <Buffer 01 02 03>\n\n### `parse` and `match`\n\nIn combination, equivalent to compile; may be useful if you want to\nexamine the internal structure of patterns.\n\n    var p = bitsyntax.parse('header:headerSize/binary, rest/binary');\n    var b = bitsyntax.match(p, new Buffer([1, 2, 3, 4, 5]),\n                              {headerSize: 3});\n    b.header\n    // => <Buffer 01 02 03>\n\n## Patterns\n\nPatterns are sequences of segments, each matching a value. Segments\nhave the general form\n\n     value:size/type_specifier_list\n\nThe size and type specifier list may be omitted, giving three extra\nvariations:\n\n    value\n    value:size\n    value/type_specifier_list\n\nThe type specifier list is a list of keywords separated by\nhyphens. Type specifiers are described below.\n\nPatterns are generally supplied as strings, with a comma-separated\nseries of segments.\n\n### Variable or value\n\nThe first part of a segment gives a variable name or a literal\nvalue. If a variable name is given, the value matched by the segment\nwill be bound to that variable name for the rest of the pattern. If a\nliteral value is given, the matched value must equal that value.\n\nThe special variable name `_` discards the value matched; i.e., it\nsimply skips over the appropriate number of bits in the input.\n\n### Size and unit\n\nThe size of a segment is given following the value or variable,\nseparated with a colon:\n\n    foo:32\n\nThe unit is given in the list of specifiers as `'unit' and\nan integer from 0..256, separated by a colon:\n\n    foo:4/integer-unit:8\n\nThe size is the number of units in the value; the unit is given as a\nnumber of bits. Unit can be of use, for example, when you want to\nmatch integers of a number of bytes rather than a number of bits.\n\nFor integers and floats, the default unit is 1 bit; to keep things\naligned on byte boundaries, `unit * size` must currently be a multiple\nof 8. For binaries the default unit is 8, and the unit must be a\nmultiple of 8.\n\nIf the size is omitted and the type is integer, the size defaults to\n8. If the size is omitted and the type is binary, the segment will\nmatch all remaining bytes in the input; such a segment may only be\nused at the end of a pattern.\n\nThe size may also be given as an integer variable matched earlier in\nthe pattern, as in the example given at the top.\n\n### Type name specifier\n\nOne of `integer`, `binary`, `float`. If not given, the default is\n`integer`.\n\nAn integer is a big- or little-endian, signed or unsigned\ninteger. Integers up to 32 bits are supported. Signed integers are\ntwo's complement format. In JavaScript, only integers between -(2^53)\nand 2^53 can be represented, and bitwise operators are only defined on\n32-bit signed integers.\n\nA binary is simply a byte buffer; usually this will result in a slice\nof the input buffer being returned, so beware mutation.\n\nA float is a 32- or 64-bit IEEE754 floating-point value (this is the\nstandard JavaScript uses, as do Java and Erlang).\n\n### Endianness specifier\n\nIntegers may be big- or little-endian; this refers to which 'end' of\nthe bytes making up the integer are most significant. In network\nprotocols integers are usually big-endian, meaning the first\n(left-most) byte is the most significant, but this is not always the\ncase.\n\nA specifier of `big` means the integer will be parsed as big-endian,\nand `little` means the integer will be parsed as little-endian. The\ndefault is big-endian.\n\n### Signedness specifier\n\nInteger segments may include a specifier of `signed` or `unsigned`. A\nsigned integer is parsed as two's complement format. The default is\nunsigned.\n\n## Examples\n\nIn the following the matched bytes are given in array notation for\nconvenience. Bear in mind that `match()` actually takes a buffer for\nthe bytes to match against. The phrase \"returns X as Y\" or \"binds X as\nY\" means the return value is an object with value X mapped to the key\nY.\n\n    54\n\nMatches the single byte `54`.\n\n    54:32\n\nMatches the bytes [0,0,0,54].\n\n    54:32/little\n\nMatches the bytes [54,0,0,0].\n\n    54:4/unit:8\n\nMatches the bytes [0,0,0,54].\n\n    int:32/signed\n\nMatches a binary of four bytes, and returns a signed 32-bit integer as\n`int`.\n\n    len:16, str:len/binary\n\nMatches a binary of `2 + len` bytes, and returns an unsigned 16-bit\ninteger as `len` and a buffer of length `len` as `str`.\n\n    len:16, _:len/binary, rest/binary\n\nMatches a binary of at least `2 + len` bytes, binds an unsigned 16-bit\ninteger as `len`, ignores the next `len` bytes, and binds the\nremaining (possibly zero-length) binary as `rest`.\n",
  "readmeFilename": "README.md",
  "_id": "bitsyntax@0.0.1",
  "dist": {
    "shasum": "f62a13419af6b1629bfab5b659dda55ea4df98c8"
  },
  "_from": "bitsyntax@*",
  "_resolved": "https://registry.npmjs.org/bitsyntax/-/bitsyntax-0.0.1.tgz"
}
