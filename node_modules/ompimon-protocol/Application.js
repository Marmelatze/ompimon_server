/**
 * @module ompimon
 * @submodule ompimon-protocol
 */
var
    util = require("util"),
    _ = require("underscore"),
    eventEmitter = require("events").EventEmitter,
    BufferBuilder = require("buffer-builder"),
    color = require("bash-color"),
    Storage = require("ompimon-storage")

    ;


module.exports = Application;

/**
 * @class Application
 * @namespace Ompimon.Protocol
 * @extends EventEmitter
 * @constructor
 * @param id {Integer}
 */
function Application(id, counters, sends, callback) {
    eventEmitter.call(this);
    this.init(id, counters, sends, callback);
}

util.inherits(Application, eventEmitter);

_.extend(Application.prototype, {


    init: function (id, counters, sends, callback) {
        /**
         * Array with all connected clients for this app
         * @property clients
         * @â€ ype Array
         */
        this.clients = [];

        /**
         * @property id
         * @type Integer
         */
        this.id = id;

        /**
         * Counter functions
         * @property counterFunctions
         * @type Array
         */
        this.counterFunctions = counters;

        /**
         * Cluster send functions
         * @property sendFunctions
         * @type Array
         */
        this.sendFunctions = sends;

        this.listeners = [];
        this.rankListeners = {};

        this.interval = null;

        this.log(process.pid);
        if (this.counterFunctions == null) {
            this.log("load missing counters");
            Storage.getCounterFunctions(this.id, function (err, counters) {
                this.counterFunctions = counters;
            }.bind(this));
        }
        if (this.sendFunctions == null) {
            this.log("load missing sends");
            Storage.getSendFunctions(this.id, function (err, sends) {
                this.sendFunctions = sends;
            }.bind(this));
        }

        this.log("created");

        var redis = Storage.createConnection();
        redis.subscribe("app:" + this.id);
        redis.on('subscribe', function(channel) {
            this.log("subscribed on " +channel);
            if (callback) {
                callback();
            }
        }.bind(this));

        redis.on('message', function (channel, message) {
            this.log("received from redis: ", color.black(message));
            monitor.message('db', 'me');

            message = JSON.parse(message);
            switch(message.action) {
                case 'send':
                    this._sendMessage(message);
                    break;
                case 'finalize':
                    this._handleFinalize();
                    break;
            }
        }.bind(this));

        this.on('finalize', function() {
            redis.quit();
        });
    },


    /**
     * add new client to app
     * @method addClient
     * @param client {Ompimon.Cluster.Client}
     * @param ranks {Array}
     */
    addClient: function (client, ranks) {
        this.clients.push(client);
        this.log("client " + client.id + " added");
        if (client.nodeId == 0) {
            var timeout = _.debounce(function() {
                this.log("app timeouted");
                this.finalize();
            }.bind(this), 1000 * 60 * 60 * 60); // 60 minutes

            timeout();

            client.buffers.on('pushed', function() {
                timeout();
            }.bind(this));

        }

        client.once('quit', function() {
            var index = this.clients.indexOf(client);
            this.clients.splice(index, 1);
        }.bind(this));
    },


    _sendMessage: function(message) {
        this.clients.forEach(function(client) {
            console.log(client.ranks);
            if (message.to == 'all' || client.ranks.indexOf(parseInt(message.to)) >= 0) {
                var data = new Buffer(message.message);
                console.log(data);
                client.write(data);
            }
        });
    },

    _handleFinalize: function() {
        this.clients.forEach(function(client) {
            if (client.nodeId == 0) {
                setTimeout(function() {
                    Storage.deleteApp(this.id);
                }.bind(this), 1000 * 60 * 60 * 30); // 30 minutes
            }
            client.quit();
        }, this);
        process.nextTick(function() {
            this.emit('finalize');
        }.bind(this));
    },

    /**
     * decide what to do with incoming data requests
     *
     {
        type: "listen" | "stop",
        sendId: null | Integer,
        rank: null | Integer
     }
     *
     * @method handleDataRequest
     * @param message {Object}
     */
    handleDataRequest: function (message) {
        var id = message.sendId;
        if (null == id) {
            id = 'all';
        }
        var array = null;
        console.log(message);

        if (null == message.rank) {
            array = this.listeners;
        } else {
            if (!this.rankListeners[message.rank]) {
                this.rankListeners[message.rank] = [];
            }
            array = this.rankListeners[message.rank];
        }

        if (message.type == "listen") {
            array.push(id);
            this.log("add listener for " + message.rank + " on func " + id);
        } else {
            var index = array.indexOf(id);
            if (index < 0) {
                return;
            }
            array.splice(index, 1);
            this.log("removed listener for "+ message.rank + " on func " + id + " (" +array.length+" left)");
        }

        if (null == this.interval) {
            this.log("start requesting data");
            this._executeDataRequest();
            this.interval = setInterval(this._executeDataRequest.bind(this), 10 * 1000);
        }
    },

    _executeDataRequest: function() {
        this.log("exec");
        var redis = Storage.createConnection();
        var send = false;
        var requestedFunctions = [];
        var sendToAll = function(message) {
            this.log("publish app:" + this.id);
            monitor.message('me', 'db');

            redis.publish("app:" + this.id, JSON.stringify({
                action: 'send',
                to: 'all',
                message: message
            }));
        }.bind(this);

        var sendToRanks = function (rank, message) {
            this.log("publish app:" + this.id);
            monitor.message('me', 'db');

            redis.publish("app:" + this.id, JSON.stringify({
                action: 'send',
                to: rank,
                message: message
            }));
        }.bind(this);

        if (this.listeners.indexOf('all') >= 0) {
            var buffer = new BufferBuilder();
            buffer.appendUInt8(0x03);
            buffer.appendUInt8(0x00);
            sendToAll(buffer.get());

            return;
        }
        var sendFuncs = [];

        this.listeners.forEach(function(func) {
            if (sendFuncs.indexOf(func) >= 0) {
                return;
            }
            sendFuncs.push(func);
            var buffer = new BufferBuilder();
            buffer.appendUInt8(0x05);
            buffer.appendUInt32BE(func);
            sendToAll(buffer.get());
            requestedFunctions.push(func);
            send = true;
        });

        _.each(this.rankListeners, function (funcs, rank) {
            if (funcs.indexOf('all') >= 0) {
                var buffer = new BufferBuilder();
                buffer.appendUInt8(0x03);
                buffer.appendUInt8(0x00);
                sendToRanks(rank, buffer.get());

                return;
            }

            var sendFuncs = [];
            funcs.forEach(function (func) {
                if (requestedFunctions.indexOf(func) >= 0 || sendFuncs.indexOf(func) >= 0) {
                    return;
                }
                sendFuncs.push(func);
                var buffer = new BufferBuilder();
                buffer.appendUInt8(0x05);
                buffer.appendUInt32BE(func);
                sendToRanks(rank, buffer.get());
                send = true;
            });
        });

        if (!send) {
            this.log("stop requesting data");
            clearInterval(this.interval);
            this.interval = null;
        }
        redis.quit();
    },

    restart: function() {
        this.clients.forEach(function(client) {
            if (client.nodeId == 0) {
                var buffer = new BufferBuilder();
                buffer.appendUInt8(0xFE);
                buffer.appendUInt8(0x00);
                client.write(buffer.get());
            }
        });
    },

    abort: function () {
        this.clients.forEach(function(client) {
            if (client.nodeId == 0) {
                var buffer = new BufferBuilder();
                buffer.appendUInt8(0xFF);
                buffer.appendUInt8(0x00);
                client.write(buffer.get());

                redis = Storage.createConnection();
                redis.publish("client:app:" + this.id+":abort", JSON.stringify({
                    status: 'ok'
                }));
            }
        }.bind(this));
    },

    finalize: function() {
        this.log("finalize");
        var redis = Storage.createConnection();

        redis.publish("client:app:" + this.id, JSON.stringify({
            action: 'finalize'
        }));
        redis.publish("app:"+this.id, JSON.stringify({
            action: 'finalize'
        }));

        Storage.finalize(this.id, function() {

        });
        redis.quit();
    },

    log: function (message) {
        var msg = "";
        for (var i=0; i < arguments.length; i++) {
            if (typeof arguments[i] != 'string') {
                msg += util.inspect(arguments[i]) + "\n";
            } else {
                msg += arguments[i] + "\n";
            }
        }

        console.log(color.blue("[app:" + this.id + "]") + ": " + msg.substr(0, msg.length-1));
    }

});