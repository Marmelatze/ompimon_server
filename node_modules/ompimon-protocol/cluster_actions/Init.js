/**
 * @module ompimon
 * @submodule ompimon-protocol
 */

var
    util = require("util"),
    _ = require("underscore"),
    binary = require("binary"),
    BufferBuilder = require('buffer-builder'),
    Storage = require("ompimon-storage"),
    redis = require("redis"),

    auth = require('ompimon-auth').auth,

    action = require("./Action"),
    Parser = require("../parser"),
    response = require("../response"),
    globals = require("../globals")
;


module.exports = Init;

/**
 * @class SendDetail
 * @namespace Ompimon.Protocol.Action
 * @extends Ompimon.Protocol.Action.Action
 * @constructor
 */
function Init() {
    action.call(this);
    this.init();
}

util.inherits(Init, action);

_.extend(Init.prototype, {
    /**
     * @property needAuthentication
     * @type {boolean}
     * @default false
     */
    needAuthentication: false,
    init: function() {
        this.needAuthentication = false
    },
    /**
     * Parse data send by cluster.
     * Will return something like:

     {
         protocolVersion: 0x01,
         username: "test",
         password: "test",
         app: "Meine Tolle Applikation",
         processes: 123782,
         nodes: 1010000,
         nodeId: 0,
         ranks: [
             123, 495
         ],
         counters: [
             "broadcast",
             "barrier"
         ],
         sends: [
             "ibsend",
             "bsend",
             "irsend"
         ],
         features: {
             restart: true,
             abort: true
         }
     }

     * @method parse
     * @param client {Ompimon.Cluster.Client}
     * @param parser {Ompimon.Protocol.Parser}
     * @return {Object}
     */
    parse: function(client, parser) {
        var result = {
            protocolVersion: parser.readUInt8(),
            username:        parser.readString(parser.readUInt8()),
            password:        parser.readString(parser.readUInt8()),
            app:             parser.readString(parser.readUInt16()),
            processes:       parser.readUInt32(),
            nodes:           parser.readUInt32(),
            nodeId:          parser.readUInt32(),
            ranks:           this._parseRanks(parser)
        };
        if (result.nodeId == 0) {
            _.extend(result, {
                counters:   this._parseCounters(parser),
                sends:      this._parseSends(parser),
                features:   this._parseFeatures(parser)
            });

        }

        return result;
    },
    _parseRanks: function(parser) {
        var ranks = [];
        var count = parser.readUInt32();
        for (var i = 0; i < count; i++) {
            ranks.push(parser.readUInt32());
        }

        return ranks;
    },
    _parseCounters: function(parser) {
        var counters = [];
        var len = parser.readUInt32();
        for (var i = 0; i < len; i++) {
            counters.push(parser.readString(parser.readUInt8()));
        }

        return counters;
    },
    _parseSends: function(parser) {
        var sends = [];
        var len = parser.readUInt32();
        for (var i = 0; i < len; i++) {
            sends.push(parser.readString(parser.readUInt8()));
            parser.readUInt8(); // send or receive function -> /dev/null
        }

        return sends;
    },
    _parseFeatures: function(parser) {
        var features = {};
        _.each(globals.features, function(feature) {
            features[feature] = false;
        });

        var count = parser.readUInt8();
        for (var i = 0; i < count; i++) {
            var feature = globals.features[parser.readUInt8()];
            features[feature] = true;
        }

        return features;
    },
    process: function(client, data, callback) {
        this._authenticate(client, data.username, data.password, function(result) {
            if (result.status != response.OK) {
                callback(result);

                return;
            }

            client.ranks = data.ranks;

            if (0 == data.nodeId) {
                client.counterFunctions = data.counters;
                client.sendFunctions = data.sends;
            }


            Storage.initAction(data, function(appId) {
                client.appId = appId;
                if (0 !== data.nodeId) {
                    Storage.getCounterFunctions(appId, function (list) {
                        client.counterFunctions = list;
                    });

                    Storage.getSendFunctions(appId, function (list) {
                        client.sendFunctions = list;
                    });
                } else {
                    var redisClient = Storage.createConnection();
                    // listen to abort and restart actions
                    redisClient.subscribe('cluster:app:' + appId);
                }

                callback(new response.Response(response.OK));
            });
            //callback(new response.Response(response.OK));


        });
    },
    _authenticate: function(client, username, password, callback) {

        auth.authenticate("cluster", username, password, function() {
            client.authenticated = true;
            callback(new response.Response(response.OK));
        }, function() {
            client.authenticated = false;
            callback(new response.Response(response.NOT_AUTHENTICATED));
        });
    }

});