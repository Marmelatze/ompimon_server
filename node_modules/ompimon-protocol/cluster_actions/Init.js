/**
 * @module ompimon
 * @submodule ompimon-protocol
 */

var
    util = require("util"),
    _ = require("underscore"),
    binary = require("binary"),
    BufferBuilder = require('buffer-builder'),
    Storage = require("ompimon-storage"),
    redis = require("redis"),

    auth = require('ompimon-auth').auth,

    action = require("./Action"),
    Parser = require("../parser"),
    response = require("../response"),
    globals = require("../globals"),
    Application = require("../Application")
;


module.exports = Init;

/**
 * @class Init
 * @namespace Ompimon.Protocol.ClusterAction
 * @extends Ompimon.Protocol.ClusterAction.Action
 * @constructor
 * @author Florian Pfitzer<pfitzer@w3p.cc>
 */
function Init() {
    action.call(this);
    this.init();
}

util.inherits(Init, action);

_.extend(Init.prototype, {
    /**
     * @property needAuthentication
     * @type {boolean}
     * @default false
     */
    needAuthentication: false,

    /**
     * Contains app data
     * @property ranks
     * @type Object
     */
    apps: {},

    init: function() {
        this.needAuthentication = false;
        this.apps = {};
    },
    /**
     * Parse data send by cluster.
     * Will return something like:

     {
         protocolVersion: 0x01,
         username: "test",
         password: "test",
         app: "Meine Tolle Applikation",
         processes: 123782,
         nodes: 1010000,
         nodeId: 0,
         ranks: [
             123, 495
         ],
         counters: [
             "broadcast",
             "barrier"
         ],
         sends: [
             "ibsend",
             "bsend",
             "irsend"
         ],
         features: {
             restart: true,
             abort: true
         }
     }

     * @method parse
     * @param client {Ompimon.Cluster.Client}
     * @param parser {Ompimon.Protocol.Parser}
     * @return {Object}
     */
    parse: function(client, parser) {
        var result = {
            protocolVersion: parser.readUInt8(),
            username:        parser.readString(parser.readUInt8()),
            password:        parser.readString(parser.readUInt8()),
            app:             parser.readString(parser.readUInt16()),
            appId:           parser.readUInt32(),
            processes:       parser.readUInt32(),
            nodes:           parser.readUInt32(),
            nodeId:          parser.readUInt32(),
            ranks:           this._parseRanks(parser)
        };

        if (result.nodeId == 0) {
            if (result.appId === 0) {
                result.appId = null;
            }
            _.extend(result, {
                counters:   this._parseCounters(parser),
                sends:      this._parseSends(parser),
                features:   this._parseFeatures(parser)
            });
        }

        return result;
    },
    _parseRanks: function(parser) {
        var ranks = [];
        var count = parser.readUInt32();
        for (var i = 0; i < count; i++) {
            ranks.push(parser.readUInt32());
        }

        return ranks;
    },
    _parseCounters: function(parser) {
        var counters = [];
        var len = parser.readUInt32();
        for (var i = 0; i < len; i++) {
            counters.push(parser.readString(parser.readUInt8()));
        }

        return counters;
    },
    _parseSends: function(parser) {
        var sends = [];
        var len = parser.readUInt32();
        for (var i = 0; i < len; i++) {
            sends.push(parser.readString(parser.readUInt8()));
            parser.readUInt8(); // send or receive function -> /dev/null
        }

        return sends;
    },
    _parseFeatures: function(parser) {
        var features = {};
        _.each(globals.features, function(feature) {
            features[feature] = false;
        });

        var count = parser.readUInt8();
        for (var i = 0; i < count; i++) {
            var feature = globals.features[parser.readUInt8()];
            features[feature] = true;
        }

        return features;
    },
    /**
     * Process parsed data
     *
     *
     * @method process
     * @param client {Ompimon.Cluster.Client}
     * @param data {Object}
     * @param callback {Function}
     */
    process: function(client, data, callback) {
        var self = this;

        if (data.protocolVersion !== globals.clusterProtocolVersion) {
            var buffer = new BufferBuilder();
            buffer.appendUInt8(0x01);
            buffer.appendUInt8(0xFF);
            callback();

            return;
        }

        this._authenticate(client, data.username, data.password, function(result) {
            if (result.status != response.OK) {
                console.log("auth failed");
                var buffer = new BufferBuilder();
                buffer.appendUInt8(0x01);
                buffer.appendUInt8(result.status);
                buffer.appendUInt32BE(0);
                self.emit('send', client, result.get());
                callback();

                return;
            }

            client.ranks = data.ranks;
            client.nodeId = data.nodeId;

            Storage.initAction(data.appId, data, function(err, appId) {
                client.log("found app " + appId);

                if (self.apps[appId] == null) {
                    self.apps[appId] = new Application(appId, data.counters, data.sends);
                    self.apps[appId].on('finalize', function() {
                        delete self.apps[appId];
                    });
                }

                client.app = self.apps[appId];

                client.app.addClient(client, client.ranks);


                if (0 !== data.nodeId) {
                    process.nextTick(function() {
                        var buffer = new BufferBuilder();
                        buffer.appendUInt8(0x01);
                        buffer.appendUInt8(0x00);
                        buffer.appendUInt32BE(appId);
                        self.emit('send', client, buffer.get());
                        callback();
                    });
                } else {
                    var redisClient = Storage.createConnection();

                    client.app.counterFunctions = data.counters;
                    client.app.sendFunctions = data.sends;


                    client.once('quit', function() {
                        redisClient.quit();
                    });

                    redisClient.on('psubscribe', function (channel) {
                        console.log("subscribed to " + channel);
                        process.nextTick(function() {
                            var buffer = new BufferBuilder();
                            buffer.appendUInt8(0x01);
                            buffer.appendUInt8(0x00);
                            buffer.appendUInt32BE(appId);
                            self.emit('send', client, buffer.get());
                            callback();
                        });
                    });

                    redisClient.on('pmessage', function(pattern, channel, message) {
                        self.processClientMessage(client, channel, message);
                    });

                    redisClient.publish('client:app', JSON.stringify({
                        action: 'start',
                        appId: appId
                    }));

                    redisClient.publish('client:app:'+appId, JSON.stringify({
                        action: 'restart'
                    }));

                    process.nextTick(function() {
                        redisClient.psubscribe('cluster:app:' + appId+":*");
                    });
                }

            });
            //callback(new response.Response(response.OK));


        });
    },
    _authenticate: function(client, username, password, callback) {

        auth.authenticate("cluster", username, password, function() {
            client.authenticated = true;
            callback(new response.Response(response.OK));
        }, function() {
            client.authenticated = false;
            callback(new response.Response(response.NOT_AUTHENTICATED));
        });
    },

    /**
     * Handle received message from redis.
     * Listens on `cluster:app:<appId>:*`
     *
     * @method processClientMessage
     * @param client {Ompimon.Cluster.Client}
     * @param channel {String}
     * @param message {String} as JSON String
     */
    processClientMessage: function(client, channel, message) {
        client.log("recevied from client on " + channel);
        monitor.message('db', 'me');

        var action = channel.split(":").pop();
        client.log("execute action " + action);
        message = JSON.parse(message);
        switch (action) {
            case 'abort':
                client.app.abort();
                break;
            case 'restart':
                client.app.restart();
                break;
            case 'dataDetail':
                this.apps[client.app.id].handleDataRequest(message);
                break;
        }
    }
});