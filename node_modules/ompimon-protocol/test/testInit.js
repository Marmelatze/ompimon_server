var protocol = require("../"),
    auth = require("ompimon-auth").auth,
    BufferBuilder = require("buffer-builder"),
    binary = require("binary"),
    protoInit = require('../actions/init'),
    cluster = require('ompimon-cluster'),
    Int64 = require('node-int64'),
    _ = require("underscore")

;

auth.type = "test";

var client = cluster.client;

client = new client.client(new Buffer(256));
client.id = "1234567890yyyasdfasdfasdfasdfasd";

var action = new protoInit.Action;


var data = {
    protocolVersion: 0x01,
    username: "test",
    password: "test",
    app: "Meine Tolle Applikation",
    processes: new Int64(123782),
    nodes: new Int64(1010000),
    nodeId: 0,
    ranks: [
        123, 495
    ],
    counters: [
        "broadcast",
        "barrier"
    ],
    sends: [
        "ibsend",
        "bsend",
        "irsend"
    ],
    features: {
        restart: true,
        abort: true
    }
};

function build() {
    var buffer = new BufferBuilder();

    buffer
        .appendUInt32BE(data.protocolVersion)
        // username
        .appendUInt8(data.username.length)
        .appendString(data.username)
        // password
        .appendUInt8(data.password.length)
        .appendString(data.password)
        // app name
        .appendUInt16BE(data.app.length)
        .appendString(data.app)
        // processes
        .appendBuffer(data.processes.buffer)
        // nodes
        .appendBuffer(data.nodes.buffer)
        // nodeId
        .appendUInt32BE(data.nodeId)
        // rank count
        .appendUInt32BE(data.ranks.length)
    ;
    // ranks
    data.ranks.forEach(function(rank) {
        buffer.appendUInt32BE(rank);
    });

    // counter functions
    buffer.appendUInt32BE(data.counters.length);
    data.counters.forEach(function(counter) {
        buffer.appendUInt8(counter.length);
        buffer.appendString(counter);
    });
    //send/receive functions
    buffer.appendUInt32BE(data.sends.length);
    data.sends.forEach(function(send) {
        buffer.appendUInt8(send.length);
        buffer.appendString(send);
    });

    //features
    var features = [];
    _.each(data.features, function(value, feature) {
        var id = _.invert(protoInit.featureMap)[feature];
        if (value) {
            features.push(id);
        }
    });
    buffer.appendUInt8(features.length);
    features.forEach(function(feature) {
        buffer.appendUInt8(feature);
    });


    return buffer;
}

// test parsing
exports.testParse = function(test) {
    var buffer = build();

    var result = action.parse(buffer.get());
    test.deepEqual(result, data);
    test.done();
}


exports.testProcess = function(test) {
    var data = action.parse(build().get());

    var result = action.process(client, data, function(result) {
        test.equal(result.status, 0);
        test.done();
    });
};

/*
exports.testAll = function(test) {
    var data = protocol.parse()
}*/

