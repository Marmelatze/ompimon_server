/**
 * Protocol Module handles incomming requests
 *
 * Actions:
 *
 * * {{#crossLink "Ompimon.Protocol.Action.Init"}}Init (0x01){{/crossLink}}
 * * {{#crossLink "Ompimon.Protocol.Action.Data"}}Data (0x02){{/crossLink}}
 * * {{#crossLink "Ompimon.Protocol.Action.DataRequest"}}DataRequest (0x03){{/crossLink}}
 *
 * @module ompimon
 * @submodule ompimon-protocol
*/


var
    _ = require("underscore"),
    util = require("util"),
    BufferBuilder = require('buffer-builder'),
    eventEmitter = require('events').EventEmitter,
    Parser = require("./parser"),
    globals = require("./globals")
;

/**
 * @class Protocol
 * @namespace Ompimon.Protocol
 * @extends EventEmitter
 * @constructor
 */
function Protocol() {

}

util.inherits(Protocol, eventEmitter);

module.exports = Protocol;

var actionMap = {};
_.each(globals.actions, function(actionClass, id) {
    var action = require('./actions/' + actionClass);
    actionMap[id] = new action();
});


_.extend(Protocol.prototype, {
    /**
     * Parse a message received by the cluster
     *
     * @method parse
     * @async
     * @param client {Ompimon.Cluster.Client}
     * @param callback will be called on error or success, first param buffer function(buf) {...}
     */
    parse: function (client, callback) {
        var self = this;
        var buffer = client.buffers.getBuffer();
        if (null == buffer) {
            return;
        }

        var parser = new Parser(buffer);

        this._doParse(client, parser, callback);
    },
    _doParse: function (client, parser, callback) {
        var self = this;
        var offset = parser.offset;
        var result = null;
        try {

            var action = parser.readUInt8();
            var actionClass = actionMap[action];
            if (!actionClass) {
                result = new BufferBuilder();
                result.appendUInt8(action);
                result.appendUInt8(0x02); // invalid input

                this.send(client, result.get());

                return false;
            }

            // check authentication
            if (!client.authenticated && actionClass.needAuthentication) {
                result = new BufferBuilder();
                result.appendUInt8(action);
                result.appendUInt8(0x03); // not authenticated
                self.send(client, result.get());

                return;
            }
            result = actionClass.parse(client, parser);
        } catch (err) {
            if (!err instanceof RangeError) {
                throw err;
            }

            var buffer = parser.buffer;
            buffer = buffer.slice(offset, buffer.length);
            client.buffers.prepend(buffer);

            return false;
        }
        actionClass.process(client, result, function(response) {
            var buffer = new BufferBuilder();
            buffer.appendUInt8(action);
            buffer.appendUInt8(response.status);

            self.send(client, buffer.get());
        });
        if (!parser.atEnd()) {
            this._doParse(client, parser, callback);
        } else {
            client.emit('parsed');
            if (callback) {
                callback();
            }
        }

        return true;
    },
    send: function (client, message) {
        this.emit('send', client, message);
    },
    /**
     * Global Settings see {{#crossLink "Ompimon.Protocol.Globals"}}{{/crossLink}}
     * @property globals
     */
    globals: require("./globals")
});