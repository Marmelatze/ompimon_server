/**
 * Protocol Module handles incomming requests on both sides, client and cluster
 *
 * Cluster Actions:
 *
 * * {{#crossLink "Ompimon.Protocol.ClusterAction.Init"}}0x01: Init{{/crossLink}}
 * * {{#crossLink "Ompimon.Protocol.ClusterAction.Data"}}0x02: Data{{/crossLink}}
 * * {{#crossLink "Ompimon.Protocol.ClusterAction.DataDetail"}}0x03: DataDetail{{/crossLink}}
 * * {{#crossLink "Ompimon.Protocol.ClusterAction.TotalSend"}}0x04: TotalSend{{/crossLink}}
 * * {{#crossLink "Ompimon.Protocol.ClusterAction.SendDetail"}}0x05: SendDetail{{/crossLink}}
 * * {{#crossLink "Ompimon.Protocol.ClusterAction.TotalCounter"}}0x06: TotalCounter{{/crossLink}}
 * * {{#crossLink "Ompimon.Protocol.ClusterAction.Finalize"}}0xFF: Finalize{{/crossLink}}
 *
 * Client Actions:
 *
 * * {{#crossLink "Ompimon.Protocol.ClientAction.Login"}}0x01: Login{{/crossLink}}
 * * {{#crossLink "Ompimon.Protocol.ClientAction.Applications"}}0x02: Applications{{/crossLink}}
 * * {{#crossLink "Ompimon.Protocol.ClientAction.AppDetail"}}0x03: AppDetail{{/crossLink}}
 * * {{#crossLink "Ompimon.Protocol.ClientAction.Counter"}}0x04: Counter{{/crossLink}}
 * * {{#crossLink "Ompimon.Protocol.ClientAction.CounterDetail"}}0x05: CounterDetail{{/crossLink}}
 * * {{#crossLink "Ompimon.Protocol.ClientAction.Send"}}0x06: Send{{/crossLink}}
 * * {{#crossLink "Ompimon.Protocol.ClientAction.SendDetail"}}0x07: SendDetail{{/crossLink}}
 *
 * @module ompimon
 * @submodule ompimon-protocol
*/

var
    _ = require("underscore"),
    util = require("util"),
    BufferBuilder = require('buffer-builder'),
    eventEmitter = require('events').EventEmitter,
    Parser = require("./parser"),
    globals = require("./globals")
;

/**
 * @class Protocol
 * @namespace Ompimon.Protocol
 * @extends EventEmitter
 * @author Florian Pfitzer<pfitzer@w3p.cc>
 * @constructor
 */
function Protocol() {
    this.init();
}

util.inherits(Protocol, eventEmitter);

module.exports = Protocol;


_.extend(Protocol.prototype, {

    /**
     * Object with cluster actions and ids
     * @property clusterActions
     * @type Object
     */
    clusterActions: {},

    /**
     * Object with client actions and ids
     * @property clientActions
     * @type Object
     */
    clientActions: {},

    init: function() {
        var self = this;
        _.each(this.globals.clusterActions, function(actionClass, id) {
            var action = require('./cluster_actions/' + actionClass);

            var instance = new action();
            this.clusterActions[id] = instance;
            instance.code = id;
            instance.on('send', function (client, message) {
                if (null === message) {
                    return;
                }
                console.log("write", message);
                self._send(client, message);
            });
        }, this);

        _.each(this.globals.clientActions, function(actionClass, id) {
            var action = require('./client_actions/' + actionClass);
            var instance = new action();
            instance.on('send', function (client, message) {
                if (null === message) {
                    return;
                }
                var buffer = new BufferBuilder();
                buffer.appendUInt8(id);
                buffer.appendBuffer(message);

                self._send(client, buffer.get());
            });
            this.clientActions[id] = instance;
        }, this);
    },
    /**
     * Parse a message received by the cluster
     *
     * @method parseCluster
     * @async
     * @param client {Ompimon.Cluster.Client}
     * @param callback will be called on error or success, first param buffer function(buf) {...}
     */
    parseCluster: function (client, callback) {
        var self = this;
        var buffer = client.buffers.pop();
        if (null == buffer) {
            return;
        }
        var parser = new Parser(buffer);

        this._doParse(client, parser, callback);
    },
    /**
     * actually parse the message
     * @method _doParse
     * @private
     * @param client {Ompimon.Cluster.Client}
     * @param parser {Ompimon.Protocol.Parser}
     * @param callback {Function}
     * @return {boolean}
     */
    _doParse: function (client, parser, callback) {
        if (!client.messageCount) {
            client.messageCount = 0;
        }

        var self = this;
        var offset = parser.offset;
        var result = null;
        try {

            var action = parser.readUInt8();
            var actionClass = this.clusterActions[action];
            if (!actionClass) {
                result = new BufferBuilder();
                result.appendUInt8(action);
                result.appendUInt8(0x02); // invalid input

                this._send(client, result.get());

                return false;
            }

            // check authentication
            if (!client.authenticated && actionClass.needAuthentication) {
                result = new BufferBuilder();
                result.appendUInt8(action);
                result.appendUInt8(0x03); // not authenticated
                self._send(client, result.get());
                client.log("not authenticated");

                return;
            }
            client.log("parse " + action);
            result = actionClass.parse(client, parser);
        } catch (err) {
            if (!err instanceof RangeError) {
                throw err;
            }
            //console.log(err.stack);
            console.log("try later");
            if (client.parseTimeout == null) {
                client.parseTimeout = setTimeout(function() {
                    this.parseCluster(client, callback);
                }.bind(this), 10 * 1000);
            }
/*
            var fs = require("fs");
            fs.writeFile("failed_dump"+(new Date()).getTime()+".bin", parser.buffer, function() {
                console.log("wrote "+ parser.buffer.length+" bytes")
            });*/

            return false;
        }
        client.parseTimeout = null;
        monitor.message('cluster:'+client.id, 'me', action, result);

        client.messageCount++;
        client.log("process " + action + "|" + client.messageCount);
        actionClass.process(client, result, function(response) {
            if (null != response) {
                console.log("processed " + action);
                var buffer = new BufferBuilder();
                buffer.appendUInt8(action);
                buffer.appendUInt8(response.status);

                self._send(client, buffer.get());
            }

            client.emit('parsed', result);
            if (callback) {
                callback();
            }

        });


        return true;
    },

    /**
     * @event send
     * @param client {*} Client
     * @param message {Buffer}
     */
    /**
     * Send messages back to client
     * @method _send
     * @private
     * @param client {*}
     * @param message {Buffer}
     */
    _send: function (client, message) {
        console.log("send to "+ client.id + ":", message);
        process.nextTick(function() {
            this.emit('send', client, message);
        }.bind(this));
    },

    /**
     * Parse client messages
     * @method parseClient
     * @param client {Websocket}
     * @param message {Buffer}
     */
    parseClient: function (client, message) {
        var result = null;
        var parser = new Parser(message);

        var action = parser.readUInt8();
        var actionClass = this.clientActions[action];

        if (!actionClass) {
            result = new BufferBuilder();
            result.appendUInt8(action);
            result.appendUInt8(0x02); // invalid input

            this._send(client, result.get());

            return false;
        }

        // check authentication
        if (!client.authenticated && actionClass.needAuthentication) {
            result = new BufferBuilder();
            result.appendUInt8(action);
            result.appendUInt8(0x03); // not authenticated
            self._send(client, result.get());

            return false;
        }

        monitor.message('client:'+client.id, 'me', action, message);


        client.selectAction(action);

        result = actionClass.parse(client, parser);

        actionClass.process(client, result);
    },
    /**
     * Global Settings see {{#crossLink "Ompimon.Protocol.Globals"}}{{/crossLink}}
     * @property globals
     */
    globals: require("./globals")
});
