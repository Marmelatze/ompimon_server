/**
 * Protocol Module handles incomming requests
 *
 * Actions:
 *
 * * {{#crossLink "Ompimon.Protocol.Action.Init"}}Init (0x01){{/crossLink}}
 * * {{#crossLink "Ompimon.Protocol.Action.Data"}}Data (0x02){{/crossLink}}
 * * {{#crossLink "Ompimon.Protocol.Action.DataRequest"}}DataRequest (0x03){{/crossLink}}
 *
 * @module ompimon
 * @submodule ompimon-protocol
*/


var
    _ = require("underscore"),
    util = require("util"),
    BufferBuilder = require('buffer-builder'),
    eventEmitter = require('events').EventEmitter,
    Parser = require("./parser"),
    globals = require("./globals")
;

/**
 * @class Protocol
 * @namespace Ompimon.Protocol
 * @extends EventEmitter
 * @constructor
 */
function Protocol() {
    this.init();
}

util.inherits(Protocol, eventEmitter);

module.exports = Protocol;


_.extend(Protocol.prototype, {

    /**
     * Object with cluster actions and ids
     * @property clusterActions
     * @type Object
     */
    clusterActions: {},

    /**
     * Object with client actions and ids
     * @property clientActions
     * @type Object
     */
    clientActions: {},

    init: function() {
        var self = this;
        _.each(this.globals.clusterActions, function(actionClass, id) {
            var action = require('./cluster_actions/' + actionClass);

            this.clusterActions[id] = new action();
        }, this);

        _.each(this.globals.clientActions, function(actionClass, id) {
            var action = require('./client_actions/' + actionClass);
            var instance = new action();
            instance.on('send', function (client, message) {
                var buffer = new BufferBuilder();
                buffer.appendUInt8(id);
                buffer.appendBuffer(message);

                self._send(client, buffer.get());
            });
            this.clientActions[id] = instance;
        }, this);
    },
    /**
     * Parse a message received by the cluster
     *
     * @method parseCluster
     * @async
     * @param client {Ompimon.Cluster.Client}
     * @param callback will be called on error or success, first param buffer function(buf) {...}
     */
    parseCluster: function (client, callback) {
        var self = this;
        var buffer = client.buffers.getBuffer();
        if (null == buffer) {
            return;
        }


        var parser = new Parser(buffer);

        this._doParse(client, parser, callback);
    },
    /**
     * actually parse the message
     * @method _doParse
     * @private
     * @param client {Ompimon.Cluster.Client}
     * @param parser {Ompimon.Protocol.Parser}
     * @param callback {Function}
     * @returns {boolean}
     */
    _doParse: function (client, parser, callback) {

        var self = this;
        var offset = parser.offset;
        var result = null;
        try {

            var action = parser.readUInt8();
            var actionClass = this.clusterActions[action];
            if (!actionClass) {
                result = new BufferBuilder();
                result.appendUInt8(action);
                result.appendUInt8(0x02); // invalid input

                this._send(client, result.get());

                return false;
            }

            // check authentication
            if (!client.authenticated && actionClass.needAuthentication) {
                result = new BufferBuilder();
                result.appendUInt8(action);
                result.appendUInt8(0x03); // not authenticated
                self._send(client, result.get());
                console.log("not authenticated");

                return;
            }
            console.log("parse " + action);
            result = actionClass.parse(client, parser);
        } catch (err) {
            if (!err instanceof RangeError) {
                throw err;
            }
            console.log("try later");

            var buffer = parser.buffer;
            buffer = buffer.slice(offset, buffer.length);
            client.buffers.prepend(buffer);

            return false;
        }
        console.log("process " + action);
        console.log(result);
        console.log("----");
        actionClass.process(client, result, function(response) {
            console.log("processed " + action);
            var buffer = new BufferBuilder();
            buffer.appendUInt8(action);
            buffer.appendUInt8(response.status);

            self._send(client, buffer.get());

            if (!parser.atEnd()) {
                self._doParse(client, parser, callback);
            } else {
                client.emit('parsed', result);
                if (callback) {
                    callback();
                }
            }

        });


        return true;
    },

    /**
     * @event send
     * @param client {*} Client
     * @param message {Buffer}
     */
    /**
     * Send messages back to client
     * @method _send
     * @private
     * @param client {*}
     * @param message {Buffer}
     */
    _send: function (client, message) {
        console.log("send to "+ client.id + ":", message);
        process.nextTick(function() {
            this.emit('send', client, message);
        }.bind(this));
    },

    /**
     * Parse client messages
     * @method parseClient
     * @param client {Websocket}
     * @param message {Buffer}
     */
    parseClient: function (client, message) {
        var result = null;
        var parser = new Parser(message);

        var action = parser.readUInt8();
        var actionClass = this.clientActions[action];

        if (!actionClass) {
            result = new BufferBuilder();
            result.appendUInt8(action);
            result.appendUInt8(0x02); // invalid input

            this._send(client, result.get());

            return false;
        }

        // check authentication
        if (!client.authenticated && actionClass.needAuthentication) {
            result = new BufferBuilder();
            result.appendUInt8(action);
            result.appendUInt8(0x03); // not authenticated
            self._send(client, result.get());

            return false;
        }

        client.selectAction(action);

        result = actionClass.parse(client, parser);

        actionClass.process(client, result);
    },
    /**
     * Global Settings see {{#crossLink "Ompimon.Protocol.Globals"}}{{/crossLink}}
     * @property globals
     */
    globals: require("./globals")
});