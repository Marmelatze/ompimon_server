/**
 * @module ompimon
 * @submodule ompimon-protocol
 */

var
    util = require("util"),
    _ = require("underscore"),
    BufferBuilder = require("buffer-builder"),
    async = require("async"),

    auth = require('ompimon-auth').auth,
    Storage = require("ompimon-storage"),

    parser = require("../parser"),
    response = require("../response"),


    action = require("./Action")
    ;

module.exports = CounterDetail;

/**
 * Request more detailed data of counter functions
 * Includes historical data with a timestamp.
 * Will send real time data, until other action is requested.
 *
 * @class CounterDetail
 * @namespace Ompimon.Protocol.ClientAction
 * @extends Ompimon.Protocol.ClientAction.Action
 * @constructor
 */
function CounterDetail() {
    action.call(this);
}

util.inherits(CounterDetail, action);

_.extend(CounterDetail.prototype, {
    /**
     * Parse a message
     * Will return something like:

     {
        appId: 123,
        processId: 456,
        counterId: 123939
     }

     * @method parse
     * @param client {Ompimon.Client.Client}
     * @param parser {Ompimon.Protocol.Parser}
     */
    parse: function (client, parser) {

        return {
            appId: parser.readUInt32(),
            processId: parser.readUInt32(),
            counterId: (parser.readUInt8()) ? parser.readUInt32() : null
        }
    },


    /**
     * processes parsed data
     * @method process
     * @param client {Ompimon.Client.Client}
     * @param data {Object}
     */
    process: function (client, data) {
        client.selectApp(data.appId);

        if (data.counterId == null) {
            monitor.message('me', 'db', 0x05);

            this._getAllCounters(data.appId, data.processId, function (err, data) {
                monitor.message('db', 'me', 0x05, data);
                this.emit('send', client, this.buildData(data));
            }.bind(this));
        } else {
            monitor.message('me', 'db', 0x05);

            Storage.getCounterData(data.appId, data.counterId, data.processId, function (err, data) {
                monitor.message('db', 'me', 0x05, data);

                this.emit('send', client, this.buildData(data));
            }.bind(this));
        }

        //listen for realtime events
        // listen for real time data
        Storage._getCounterFunctionById(data.appId, data.counterId, function(funcName) {
            client.on('message', function (messages) {
                var sendMessages = [];
                messages.forEach(function (message) {
                    if (message.type != "counter" || message.rank != data.processId) {
                        return;
                    }
                    if (message.funcName != funcName) {
                        return;
                    }

                    sendMessages.push(message);
                });

                if (sendMessages.length > 0) {
                    monitor.message('db', 'me', 0x05, sendMessages);
                    this.emit('send', client, this.buildData(sendMessages));
                }
            }.bind(this));
        }.bind(this));

    },

    _getAllCounters: function (appId, processId, callback) {
        var self = this;
        Storage.getCounterFunctions(appId, function (err, counters) {
            if (err) {
                console.error(err);

                return;
            }

            var tasks = [];
            counters.forEach(function (counter, counterId) {
                tasks.push(function (callback) {
                    Storage.getCounterData(appId, counterId, processId, callback);
                });
            });

            async.parallel(tasks, function (err, results) {
                if (err) {
                   console.error(err);

                   return;
                }

                results = _.flatten(results);

                callback(null, results);

            });
        });
    },

    /**
     * Summarize by timestamp
     * @method filterData
     * @param {Array} data
     * @return Array
     * @private
     */
    _filterData: function(data) {

        var grouped = _.groupBy(data, function (res) {
            return Math.round(res.timestamp/1000);
        });

        return _.map(grouped, function (items, key) {
            var total = 0;
            _.each(items, function (value) {
                total += parseInt(value.value);
            });

            return {
                timestamp: key,
                value: total
            };
        });
    },

    /**
     * Will parse an object to binary

     [
         {
             timestamp: 1234737127, // unix timestamp (seconds)
             value: 1239239
         },
         {
             timestamp: 28423742234,
             value: 1237123
         }
     ]

     * @method buildData
     * @param data {Object}
     * @return Buffer
     */
    buildData: function (data) {
        var buffer = new BufferBuilder();



        data = this._filterData(data);

        var time = _.max(data, function(item) {
            return item.timestamp;
        });
        buffer.appendUInt32BE(time.timestamp);
        buffer.appendUInt16BE(data.length); // length

        data.forEach(function (process) {
            buffer.appendUInt32BE(process.timestamp);
            buffer.appendUInt32BE(process.value);
        });

        return buffer.get();
    }

});