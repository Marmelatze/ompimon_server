/**
 * @module ompimon
 * @submodule ompimon-protocol
 */

var
    util = require("util"),
    _ = require("underscore"),
    BufferBuilder = require("buffer-builder"),
    Int64 = require("node-int64"),

    auth = require('ompimon-auth').auth,
    Storage = require("ompimon-storage"),


    parser = require("../parser"),
    response = require("../response"),


    action = require("./Action")
    ;

module.exports = Send;

/**
 * Request data of send function.
 * Will query the cluster for data not available in the database.
 * Will send realtime data, until another action is requested.
 *
 * @class Send
 * @namespace Ompimon.Protocol.ClientAction
 * @extends Ompimon.Protocol.ClientAction.Action
 * @constructor
 */
function Send() {
    action.call(this);
}

util.inherits(Send, action);

_.extend(Send.prototype, {
    /**
     * Parse a message
     * Will return something like:

     {
        appId: 123,
        sendId: 4949 // optinal
     }

     * @method parse
     * @param client  {Ompimon.Client.Client}
     * @param parser {Ompimon.Protocol.Parser}
     */
    parse: function (client, parser) {

        return {
            appId: parser.readUInt32(),
            sendId: (parser.readUInt8()) ? parser.readUInt32() : null
        }

    },


    /**
     * processes parsed data
     * @method process
     * @param client {Ompimon.Client.Client}
     * @param data {Object}
     */
    process: function (client, data) {
        client.selectApp(data.appId);
        // request missing data

        if (data.sendId != null) {
            var redis = Storage.createConnection();
            var message = {
                type: 'listen',
                sendId: data.sendId,
                rank: null
            };
            monitor.message('me', 'db', 0x06);
            client.log("request missing data from cluster cluster:app:"+data.appId+"dataDetail", message);
            redis.publish('cluster:app:'+data.appId+':dataDetail', JSON.stringify(message));
            redis.on('publish', function() {
                redis.quit();
            });
        } else {
            monitor.message('me', 'db', 0x06);
            Storage.getLastSendData(data.appId, data.sendId, function (err, returnData) {
                monitor.message('db', 'me', 0x06, data);

                if (err) {
                    return console.error(err);
                }
                console.log("send");

                if (returnData.length == 0 && data.sendId != null) {
                    return;
                }
                console.log(returnData);

                this.emit('send', client, this.buildData(returnData));
            }.bind(this));
        }

        client.log("resolve " + data.appId + " " + data.sendId);
        Storage._getSendFunctionById(data.appId, data.sendId, function (funcName) {
            client.log("listen for " + funcName + " functions");
            // listen for real time data
            client.on('message', function (messages) {

                var sendMessages = [];
                messages.forEach(function (message) {
                    if ("send" != message.type) {
                        return;
                    }
                    if (message.funcName != funcName) {
                        return;
                    }
                    sendMessages.push(message);
                });

                if (sendMessages.length > 0) {
                    monitor.message('db', 'me', 0x06, sendMessages);

                    this.emit('send', client, this.buildData(sendMessages));
                }

            }.bind(this));
        }.bind(this));

        client.once('change', function () {
            client.log("stop retrieving special data from cluster");
            var redis = Storage.createConnection();
            var message = {
                type: 'stop',
                sendId: data.sendId,
                rank: null
            };
            redis.publish('cluster:app:'+data.appId+':dataDetail', JSON.stringify(message));
            redis.on('publish', function() {
                redis.quit();
            });
        });

    },

    /**
     * Will parse an object to binary

     [
         {
             senderId: 4848,
             receiverId: 4949,
             bytes: Int64(202)
         },
         {
             senderId: 49494,
             receiverId: 494949,
             bytes: Int64(4949)
         }
     ]

     * @method buildData
     * @param data {Object}
     * @return Buffer
     */
    buildData: function (data) {
        var buffer = new BufferBuilder();
        if (data.length <= 0) {
            return null;
        }

        var time = _.max(data, function(item) {
            return item.timestamp;
        });

        buffer.appendUInt32BE(Math.round(time.timestamp/1000));
        buffer.appendUInt16BE(data.length); // length

        data.forEach(function (process) {
            var size = new Int64(parseInt(process.size));

            buffer
                .appendUInt32BE(process.rank)
                .appendUInt32BE(process.toRank)
                .appendBuffer(size.buffer)
            ;
        });

        return buffer.get();
    }

});