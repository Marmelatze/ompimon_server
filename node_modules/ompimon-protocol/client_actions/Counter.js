/**
 * @module ompimon
 * @submodule ompimon-protocol
 */

var
    util = require("util"),
    _ = require("underscore"),
    BufferBuilder = require("buffer-builder"),
    async = require("async"),

    Storage = require("ompimon-storage"),
    auth = require('ompimon-auth').auth,


    parser = require("../parser"),
    response = require("../response"),


    action = require("./Action")
    ;

module.exports = Counter;

/**
 * @class Counter
 * @namespace Ompimon.Protocol.ClientAction
 * @extends Ompimon.Protocol.ClientAction.Action
 * @constructor
 */
function Counter() {
    action.call(this);
}

util.inherits(Counter, action);

_.extend(Counter.prototype, {
    /**
     * Parse a message
     * Will return something like:

     {
        appId: 123,
        counterId: 2 // optional
     }

     * @method parse
     * @param client {Websocket}
     * @param parser {Ompimon.Protocol.Parser}
     */
    parse: function (client, parser) {
        return {
            appId: parser.readUInt32(),
            counterId: (parser.readUInt8()) ? parser.readUInt32() : null
        }
    },


    /**
     * processes parsed data
     * @param client {Websocket}
     * @param data {Object}
     */
    process: function (client, data) {
        console.log(data);
        client.selectApp(data.appId);

        if (data.counterId == null) {

            this._getAllCounters(data.appId, function (err, data) {
                console.log(err, data);
                this.emit('send', client, this.buildData(data));
            }.bind(this))
        }


        Storage.getLastCounterData(data.appId, data.counterId, function (err, data) {
            if (err) {
                console.error(err);

                return;
            }

            this.emit('send', client, this.buildData(data));
        }.bind(this));


        client.on('message', function (message) {
            console.log(message);
        });
    },

    _getAllCounters: function (appId, callback) {
        Storage.getCounterFunctions(appId, function (err, counters) {
            if (err) {
                console.error(err);

                return;
            }

            var tasks = [];
            counters.forEach(function (counter, counterId) {
                tasks.push(function(callback) {
                    console.log(counter);
                    Storage.getLastCounterData(appId, counterId, callback);
                });
            });
            console.log(tasks);

            async.parallel(tasks, function (err, data) {
                if (err) {
                    console.log(error);
                    return;
                }

                var result = {};
                data.forEach(function(counterData) {
                    counterData.forEach(function (counter) {
                        if (!result[counter.rank]) {
                            result[counter.rank] = counter.value;
                        } else {
                            result[counter.rank] += counter.value;
                        }
                    });
                });

                var output = [];
                _.each(result, function (value, key) {
                    output.push({
                        rank: key,
                        value: value
                    });
                });

                callback(null, output);

            });

        });
    },

    /**
     * Will parse an object to binary

     [
         {
             rank: 12039393,
             value: 3038373373
         },
         {
             rank: 3455,
             value: 3038373373
         }
     ]

     * @method buildData
     * @param data {Object}
     * @return Buffer
     */
    buildData: function (data) {
        var buffer = new BufferBuilder();

        buffer.appendUInt32BE(data.length); // numberOfProcesses

        data.forEach(function (process) {
            buffer.appendUInt32BE(process.rank);
            buffer.appendUInt32BE(process.value);
        });

        return buffer.get();
    }

});