/**
 * @module ompimon
 * @submodule ompimon-protocol
 */

var
    util = require("util"),
    _ = require("underscore"),
    BufferBuilder = require('buffer-builder'),
    async = require("async"),

    auth = require('ompimon-auth').auth,
    Storage = require("ompimon-storage"),



    parser = require("../parser"),
    response = require("../response"),
    globals = require("../globals"),


    action = require("./Action")
    ;

module.exports = AppDetail;

/**
 * Request details of running applications
 *
 * @class AppDetail
 * @namespace Ompimon.Protocol.ClientAction
 * @extends Ompimon.Protocol.ClientAction.Action
 * @constructor
 * @author Florian Pfitzer<pfitzer@w3p.cc>
 */
function AppDetail() {
    action.call(this);
}

util.inherits(AppDetail, action);

_.extend(AppDetail.prototype, {
    /**
     * Parse a message
     * Will return something like:

     {
        appId: 123
     }

     * @method parse
     * @param client {Ompimon.Client.Client}
     * @param parser {Ompimon.Protocol.Parser}
     */
    parse: function (client, parser) {
        return {
            appId: parser.readUInt32()
        }
    },


    /**
     * processes parsed data
     * @method process
     * @param client {Ompimon.Client.Client}
     * @param data {Object}
     */
    process: function (client, data) {
        client.selectApp(data.appId);
        monitor.message('me', 'db', 0x03);

        async.parallel([
            function (callback) {
                Storage.getApplicationDetails(data.appId, callback);
            },
            function (callback) {
                Storage.getRanks(data.appId, callback);
            },
            function (callback) {
                Storage.getCounterFunctions(data.appId, callback);
            },
            function (callback) {
                Storage.getSendFunctions(data.appId, callback);
            }
        ], function (err, data) {
            if (err) {
                console.log(err);
            } else {
                monitor.message('db', 'me', 0x03, data);
                console.log(data);
                this.emit('send', client, this.buildData(data[0], data[1], data[2], data[3]));
            }
        }.bind(this));
    },

    /**
     * Will parse an object to binary

     {
        numberOfProcesses: 123,
        numberOfNodes: 1239,
        ranks: [1, 2, 3, 4],
        counters: [
            "broadcast",
            "barrier"
        ],

        sends: [
            "isend",
            "bsend"
        ],

        features: {
            restart: true,
            abort: true
        }
     }

     * @method buildData
     * @param data {Object}
     * @param ranks {Array}
     * @param counters {Array}
     * @param sends {Array}
     * @return Buffer
     */
    buildData: function (data, ranks, counters, sends) {
        if (!data) {
            return null;
        }
        console.log(data, counters, sends);
        var buffer = new BufferBuilder();
        buffer
            .appendUInt32BE(ranks.length) // numberOfProcesses
            .appendUInt32BE(data.nodes) // numberOfNodes
        ;

        // ranks
        ranks.forEach(function (rank) {
            buffer.appendUInt32BE(rank);
        });

        // counters
        buffer.appendUInt32BE(counters.length); // numberOfCounterFunctionToTrack
        counters.forEach(function(counter) {
            buffer
                .appendUInt8(counter.length)
                .appendString(counter)
            ;
        });

        // sends
        buffer.appendUInt32BE(sends.length);
        sends.forEach(function (send) {
            buffer
                .appendUInt8(send.length)
                .appendString(send)
            ;
        });

        // features
        var features = [];
        _.each(globals.features, function (name, id) {
            if (null !== data[name]) {
                features.push(id);
            }
        });
        buffer.appendUInt8(features.length);
        features.forEach(function (feature) {
            buffer.appendUInt8(feature);
        });

        return buffer.get();
    }

});