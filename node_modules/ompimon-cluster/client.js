/**
 * @module ompimon
 * @submodule ompimon-cluster
 */

var
    eventEmitter = require('events').EventEmitter,
    util = require("util"),
    _ = require("underscore"),
    BufferStack = require("./BufferStack"),
    color = require("bash-color"),
    crypto = require("crypto")

    ;


module.exports = Client;

/**
 * A connected cluster client
 *
 * @class Client
 * @namespace Ompimon.Cluster
 *
 * @param socket {Socket}
 * @constructor
 */
function Client (socket, id) {
    eventEmitter.call(this);
    this.init(socket, id);
}

util.inherits(Client, eventEmitter);

_.extend(Client.prototype, {

    init: function(socket, id) {
        var self = this;

        /**
         * Socket of client
         * @property socket
         * @type Socket
         */
        this.socket = socket;
        /**
         * unique id
         * @property id
         * @type Integer
         */
        this.id = id || crypto.createHash('md5').update(crypto.randomBytes(512)).digest('hex');
        /**
         * Whether this client is authenticated
         * @property authenticated
         * @type Boolean
         * @default false
         */
        this.authenticated = false;

        /**
         * current app, if authenticated
         * @property app
         * @type Ompimon.Protocol.Application
         */
        this.app = null;

        /**
         * Ranks of this node
         * @property ranks
         * @type Array
         */
        this.ranks = [];

        /**
         * Buffers received by this client
         * @property buffers
         * @type Ompimon.Cluster.BufferStack
         */
        this.buffers = new BufferStack();
        this.log("connected");

        if (this.socket != null) {
            this.socket.on('timeout', function() {
                this.quit();
            }.bind(this));
        }
    },

    /**
     * Send buffer to client
     * @method send
     * @param data {Buffer}
     */
    send: function(data) {
        this.log("write", data);
        this.socket.write(data);
        process.nextTick(function() {
            this.emit('send', data);
        }.bind(this));
    },

    /**
     * Quit current connection
     *
     * @method quit
     */
    quit: function () {
        this.log("quit");
        this.socket = null;
        this.emit('quit');

    },

    /**
     * Write a buffer to the client, when still connected.
     *
     * @method write
     * @param message {Buffer}
     */
    write: function (message) {
        this.log("write", message);
        this.emit('write', message);
        monitor.message('me', 'cluster:'+this.id, message.readUInt8(0), message);

        if (null !== this.socket) {
            this.socket.write(message);
        }
    },

    /**
     * Write pretty log
     * @param message {Object}
     */
    log: function (message) {
        var msg = "";
        for (var i=0; i < arguments.length; i++) {
            if (typeof arguments[i] != 'string') {
                msg += util.inspect(arguments[i]) + "\n";
            } else {
                msg += arguments[i] + "\n";
            }
        }

        console.log(color.green("[" + this.id + "]") + ": " + msg.substr(0, msg.length-1));
    },

    /**
     * fired when something is send to client
     * @event send
     * @param data {Buffer}
     */
    onSend: null



});