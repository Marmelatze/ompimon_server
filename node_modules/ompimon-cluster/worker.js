/**
 * @module ompimon
 * @submodule ompimon-cluster
 */

var eventEmitter = require('events').EventEmitter,
    net = require('net'),
    client = require('./client'),
    Protocol = require('ompimon-protocol'),
    crypto = require("crypto"),
    BufferBuilder = require('buffer-builder'),
    domain = require('domain'),

    Monitor = require("ompimon-monitor"),

    util = require("util"),
    _ = require("underscore")
;




module.exports = Worker;

/**
 * Worker process for cluster connections.
 * Cluster connections will be loadbalanced among all workers.
 *
 * @class Worker
 * @namespace Ompimon.Cluster
 *
 * @param port {Integer} Port this worker listens to
 * @param [start=true] {Boolean} Whether to start the worker immediately
 * @constructor
 * @author Florian Pfitzer<pfitzer@w3p.cc>
 */
function Worker (port, start) {
    start = typeof start !== 'undefined' ? start : true;
    eventEmitter.call(this);
    /**
     * Port this worker listens to
     * @property port
     * @type {Integer}
     */
    this.port = port;
    if (start) {
        this.start();
    }
}

util.inherits(Worker, eventEmitter);

_.extend(Worker.prototype, {
    /**
     * Start listening to incomming connections
     *
     * @method start
     */
    start: function() {
        global.monitor = new Monitor('cluster_node', process.pid);

        /*setInterval(function() {
            var memory = process.memoryUsage();
            console.log("Heap",
                Math.round(memory.heapUsed / 1024 / 1024) + " MB / "+
                    Math.round(memory.heapTotal / 1024 / 1024) + " MB"
            );
        }, 1000);
*/

        this.protocol = new Protocol();

        this.protocol.on('send', function(client, data) {
            client.write(data);
        });

        var self = this;
        var server = net.createServer(function (c) { //'connection' listener
            var d = domain.create();
            d.add(c);
            var clientInstance = new client(c);

            d.add(clientInstance);
            d.on('error', function (er) {
                console.error("error", er);
                c.end();
                clientInstance.quit();
            });

            self.connect(clientInstance);
            c.on('end', function () {
                console.log('client '+clientInstance.id+' disconnected');
                monitor.removeComponent('cluster', clientInstance.id);
                clientInstance.quit();
                clientInstance = null;
            });

        });


        server.listen(this.port, function () { //'listening' listener
            console.log("Server started on port " + self.port);
        });
    },

    /**
     * Handle connection of new clients and parsing of incomming messages.
     *
     * When something is pushed to the {{#crossLink "Ompimon.Cluster.BufferStack"}}{{/crossLink}} of the client,
     * the {{#crossLink "Ompimon.Protocol.Protocol/parseCluster:method"}}protocol handler{{/crossLink}} will be notified.
     *
     * @method connect
     * @param client {Ompimon.Cluster.Client}
     */
    connect: function(client) {
        var self = this;

        console.log("client "+ client.id+" connected");
        monitor.addComponent("cluster", client.id);

        client.socket.on('data', function(data) {
            self.process(client, data);
        });

        client.buffers.on('pushed', function(buffers) {
            this.protocol.parseCluster(client);
        }.bind(this));
    },

    /**
     * Process received messages.
     * Messages will be pushed to the {{#crossLink "Ompimon.Cluster.BufferStack"}}{{/crossLink}} of the client, for later
     * parsing.
     *
     * @method process
     * @param client {Ompimon.Cluster.process}
     * @param data {Buffer}
     * @param [callback] {Function}
     */
    process: function(client, data, callback) {
        var string = data.toString('utf-8').trim().replace(/(\r\n|\n|\r)/gm,"");
        console.log("received from " + client.id+":");
        console.log(data);
        //console.log(string);

        if (callback) {
            client.once('parsed', callback);
        }

        client.buffers.push(data);
    }
});