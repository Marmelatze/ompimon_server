/**
 * @module ompimon
 * @submodule ompimon-cluster
 */
var
    util = require("util"),
    eventEmitter = require('events').EventEmitter,
    Buffer = require("buffer").Buffer,
    _ = require("underscore")
;

module.exports = BufferStack;

/**
 * Holds buffers received by a client for later parsing.
 *
 * @class BufferStack
 * @namespace Ompimon.Cluster
 * @constructor
 */
function BufferStack() {
    eventEmitter.call(this);
}

util.inherits(BufferStack, eventEmitter);

_.extend(BufferStack.prototype, {
    /**
     * Holds a buf
     * @private
     * @property stack
     * @type Buffer
     */
    stack: null,
    /**
     * Push a new buffer to the stack
     * fires an pushed event
     * @param buffer {Buffer}
     * @method push
     *
     */
    push: function(buffer) {
        if (null === this.stack) {
            this.stack = buffer;
        } else {
            this.stack = Buffer.concat([this.stack, buffer]);
        }
        process.nextTick(function() {
            this.emit('pushed', this);
        }.bind(this));
    },

    /**
     * Return the whole stack as buffer
     *
     * @method getBuffer
     * @return {Buffer}
     */
    getBuffer: function() {
        var stack = this.stack;
        this.stack = null;
        return stack;
    },
    /**
     * returns true if stack is empty
     * @method empty
     * @return boolean
     */
    empty: function() {
        return this.stack.length == 0;
    },

    /**
     * Prepend a buffer to the stack. Will be used if a message was not
     * received in total. Will be reparsed later.
     *
     * @method prepend
     * @param buffer
     */
    prepend: function (buffer) {
        if (null == this.stack) {
            this.stack = buffer;
        } else {
            this.stack = Buffer.concat([buffer, this.stack]);
        }
    },
    /**
     * Will be fired if a new buffer is pushed to the stack
     *
     * @event pushed
     */
    pushed: function() {}
});

