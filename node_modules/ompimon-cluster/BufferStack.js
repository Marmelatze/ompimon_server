/**
 * @module ompimon
 * @submodule ompimon-cluster
 */
var
    util = require("util"),
    eventEmitter = require('events').EventEmitter,
    Buffer = require("buffer").Buffer,
    _ = require("underscore")
;

module.exports = BufferStack;

/**
 * Holds buffers received by a client for later parsing.
 *
 * @class BufferStack
 * @namespace Ompimon.Cluster
 * @constructor
 * @author Florian Pfitzer<pfitzer@w3p.cc>
 */
function BufferStack() {
    eventEmitter.call(this);
}

util.inherits(BufferStack, eventEmitter);

_.extend(BufferStack.prototype, {
    /**
     * Holds a buf
     * @private
     * @property stack
     * @type Buffer
     */
    stack: [],

    /**
     * true if the last message on the stack was only transmitted partial
     * @property partial
     * @type boolean
     */
    partial: false,
    /**
     * missing length of the last partial message
     * @property partialLength
     * @type Integer
     */
    missingLength: 0,
    /**
     * Push a new buffer to the stack
     * fires an pushed event
     * @param buffer {Buffer}
     * @method push
     *
     */
    push: function(buffer) {
        console.log(buffer.length);
        if (!this.partial) {
            var length = buffer.readUInt32BE(0);

            if (buffer.length -4 < length) {
                this.partial = buffer.slice(4);
                this.missingLength = length - buffer.length + 4;
                console.log("missing", this.missingLength, "bytes");

                return;
            }

            this._push(buffer.slice(4));
            return;
        }

        if (buffer.length <= this.missingLength) { // new buffer fits completly into partial buffer
            this.partial = Buffer.concat([this.partial, buffer]);
            this.missingLength -= buffer.length;

            if (0 == this.missingLength) {
                this.missingLength = 0;
                this._push(this.partial);
                this.partial = false;
            }

            return;
        }

        // new buffer contains also a new message
        var oldBuffer = Buffer.concat([this.partial, buffer.slice(0, this.missingLength)]);
        this._push(oldBuffer);
        this.partial = false;
        var newBuffer = buffer.slice(this.missingLength);
        this.push(newBuffer);
    },

    _push: function(buffer) {
        this.stack.push(buffer);
        process.nextTick(function() {
            this.emit('pushed');
        }.bind(this));
    },

    /**
     * Return the whole stack as buffer
     *
     * @method getBuffer
     * @return {Buffer}
     */
    pop: function() {
        if (this.empty()) {
            return null;
        }

        return this.stack.shift();
    },
    /**
     * returns true if stack is empty
     * @method empty
     * @return boolean
     */
    empty: function() {
        return this.stack.length == 0;
    },

    /**
     * Clear the buffer
     * @method clear
     */
    clear: function() {
        this.stack = [];
    },

    /**
     * Will be fired if a new buffer is pushed to the stack
     *
     * @event pushed
     */
    onPushed: function() {}
});

