/**
 * Stupid websocket testclient
 *
 * @module ompimon
 * @submodule ompimon-client
 */
var
    BufferBuilder = require("buffer-builder"),
    stub = require("ompimon-protocol/test-client-stub"),
    _ = require("underscore"),
    Parser = require("ompimon-protocol/parser"),
    globals = require("ompimon-protocol/globals"),
    Table = require("cli-table"),
    program = require("commander"),
    async = require("async"),
    color = require("bash-color")
;

var action = 0x04;

var appId = process.argv[2];
console.log(appId);


var WebSocket = require('ws');



/**
 * @class TestClient
 * @namespace Ompimon.Client
 * @param uri {String} uri for the webservice
 * @constructor
 */
function TestClient(uri) {
    /**
     * URI of the webservice
     * @property uri
     * @type String
     */
    this.uri = uri;

    this.ws = null;

    this.isLoggedIn = false;

    this.actionMapping = {
        0x02: 'Applications',
        0x03: 'AppDetail',
        0x04: 'Counter',
        0x05: 'CounterDetail',
        0x06: 'Send',
        0x07: 'SendDetail',
        0xA0: 'Restart',
        0xA1: 'Abort',
        0xA2: 'Finalize',
        0xA3: 'Reinit'
    };


    this.init();
}

_.extend(TestClient.prototype, {
    init: function() {
        console.log("Welcome to the interactive ompimon test client. Press s+Enter to put the client to sleep and stop receiving realtime data");
        this.ws = new WebSocket(this.uri);
        this.ws.on('open', function() {
            this.ws.on('message', _.bind(this.handleMessage, this));
            this.sendLogin();
        }.bind(this));

        process.stdin.on('data', function (chunk) {
            if ("s" == chunk.trim()) {
                this.sleep();
            }
        }.bind(this));

    },
    send: function(buffer) {
        this.ws.send(buffer, {binary: true});
    },
    sendBuffer: function(action, buf) {
        var buffer = new BufferBuilder();
        buffer.appendUInt8(action);
        buffer.appendBuffer(buf);
        this.send(buffer.get());
    },
    handleMessage: function(message) {
        console.log("received:");
        console.log(message);

        var parser = new Parser(message);
        var action = parser.readUInt8();
        if (action == 1) {
            this.parseLogin(parser);

            return;
        }
        var actionName = this.actionMapping[action];
        this.actions[actionName].parse(parser);
    },
    prompt: function() {
        var actions = [];
        _.each(this.actions, function(action, name) {
            if (action.build == null) {
                return;
            }
            actions.push(name);
        });
        console.log("Select an action:");
        program.choose(actions, function(i) {
            this.actions[actions[i]].build.apply(this);
        }.bind(this));
    },
    sendLogin: function() {
        var data = stub.buildLogin(stub.loginData);
        var buffer = new BufferBuilder();
        buffer.appendUInt8(0x01);
        buffer.appendBuffer(data);
        this.send(buffer.get());
    },
    parseLogin: function(parser) {
        if (parser.readUInt8() == 0) {
            this.isLoggedIn = true;
            this.prompt();
        } else {
            console.log("authorization failed")
        }
    },
    sleep: function() {
        var buffer = new BufferBuilder();
        buffer.appendUInt8(0xFF);
        this.send(buffer.get());

        this.prompt();
    },
    askParameters: function(params, callback) {
        var result = {};
        var tasks = [];
        params.forEach(function(param) {
            tasks.push(function(callback) {
                program.prompt(param+": ", function(value) {
                    result[param] = value;
                    callback(null);
                });
            });
        });

        async.series(tasks, function() {
            callback(result);
        });
    }
});


TestClient.prototype.actions = {
    'Applications': {
        build: function () {
            var data = stub.buildApplication();
            var buffer = new BufferBuilder();
            buffer.appendUInt8(0x02);
            buffer.appendBuffer(data);
            this.send(buffer.get());
        },
        parse: function (parser) {
            var length = parser.readUInt8();
            var table = new Table({
                head: ['Id', 'Name']
            });

            for (var i = 0; i < length; i++) {
                table.push([
                    parser.readUInt32(),
                    parser.readString(parser.readUInt32())
                ]);
            }
            console.log("Application List");
            console.log(table.toString());
        }
    },
    'AppDetail': {
        build: function() {
            this.askParameters(['appId'], function(params) {
                var data = stub.buildAppDetail(params);
                var buffer = new BufferBuilder();
                buffer.appendUInt8(0x03);
                buffer.appendBuffer(data);
                this.send(buffer.get());
            }.bind(this));

        },
        parse: function(parser) {
            var result = {
                processes: parser.readUInt32(),
                nodes: parser.readUInt32(),
                ranks: [],
                counters: [],
                sends: []
            };
            for (var i = 0; i < result.processes; i++) {
                result.ranks.push(parser.readUInt32());
            }
            var counters = parser.readUInt32();
            for (var i = 0; i < counters; i++) {
                result.counters.push(parser.readString(parser.readUInt8()));
            }
            var sends = parser.readUInt32();
            for (var i = 0; i < sends; i++) {
                result.sends.push(parser.readString(parser.readUInt8()));
            }
            var features = parser.readUInt8();
            for (var i = 0; i < features; i++) {
                var name = globals.features[parser.readUInt8()];
                result[name] = true;
            }

            delete result.ranks;

            var table = new Table();
            var data = [];
            _.each(result, function(value, key) {
                var obj = {};
                obj[key] = value;
                table.push(obj);
            });
            console.log("App Details");
            console.log(table.toString());

        }
    },
    'Counter': {
        build: function() {
            this.askParameters(['appId', 'counterId'], function(params) {
                this.sendBuffer(0x04, stub.buildCounter(params));
            }.bind(this));
        },
        parse: function(parser) {
            var time = parser.readUInt32();
            var date = new Date(time*1000);
            console.log("received at ", date);

            var length = parser.readUInt32();
            var table = new Table({
                head: ['rank', 'value']
            });
            for (var i = 0; i< length; i++) {
                table.push([
                    parser.readUInt32(),
                    parser.readUInt32()
                ]);
            }
            console.log(table.toString());
        }
    },
    'CounterDetail': {
        build: function() {
            this.askParameters(['appId', 'processId', 'counterId'], function(params) {
                this.sendBuffer(0x05, stub.buildCounterDetail(params));
            }.bind(this));
        },
        parse: function(parser) {
            var time = parser.readUInt32();
            var date = new Date(time*1000);
            console.log("received at ", date);
            var length = parser.readUInt16();

            var table = new Table({
                head: ['time', 'value'],
                colWidths: [50, 20]
            });

            for (var i = 0; i < length; i++) {
                var res = {
                    timestamp: parser.readUInt32(),
                    value: parser.readUInt32()
                };
                table.push([
                    new Date(res.timestamp*1000),
                    res.value.toString()
                ]);
            }
            console.log(table.toString());
        }
    },
    'Send': {
        build: function() {
            this.askParameters(['appId', 'sendId'], function(params) {
                this.sendBuffer(0x06, stub.buildSend(params));
            }.bind(this));
        },
        parse: function(parser) {
            var time = parser.readUInt32();
            var date = new Date(time*1000);
            console.log("received at ", date);
            var length = parser.readUInt16();

            var table = new Table({
                head: ['from', 'to', 'size']
            });


            for (var i = 0; i < length; i++) {
                table.push([
                    parser.readUInt32(),
                    parser.readUInt32(),
                    parser.readUInt64()
                ]);
            }
            console.log(table.toString());
        }
    },
    'SendDetail': {
        build: function() {
            this.askParameters(['appId', 'processId', 'sendId'], function(params) {
                this.sendBuffer(0x07, stub.buildSendDetail(params));
            }.bind(this));
        },
        parse: function(parser) {
            var time = parser.readUInt32();
            var date = new Date(time*1000);
            console.log("received at ", date);

            var length = parser.readUInt16();
            var table = new Table({
                head: ['time', 'to', 'value'],
                colWidths: [50, 5, 20]
            });
            for (var i = 0; i < length; i++) {
                var date = parser.readUInt32();
                table.push([
                    new Date(date*1000),
                    parser.readUInt32(),
                    parser.readUInt64()
                ]);
            }
            console.log(table.toString());
        }
    },
    'Restart': {
        build: function() {
            this.askParameters(['appId'], function(params) {
                this.sendBuffer(0xA0, stub.buildRestart(params));
            }.bind(this));
        },
        parse: function(parser) {
            if (parser.readUInt8() == 0) {
                console.log(color.green("Restart OK"));
            } else {
                console.log(color.red("Restart failed"));
            }
        }
    },
    'Abort': {
        build: function() {
            this.askParameters(['appId'], function(params) {
                this.sendBuffer(0xA1, stub.buildAbort(params));
            }.bind(this));
        },
        parse: function(parser) {
            if (parser.readUInt8() == 0) {
                console.log(color.green("Abort OK"));
            } else {
                console.log(color.red("Abort failed"));
            }
        }
    },
    'Finalize': {
        parse: function(parser) {
            var appId = parser.readUInt32();
            console.log(color.green('App '+appId+' is finalized'));
        }
    },
    'Reinit': {
        parse: function(parser) {
            console.log(color.green("App is restarted"));
        }
    }
};

new TestClient("ws://localhost:8080");



/*
ws.on('open', function() {
    console.log("connected");

    ws.on('message', function(message) {

        if (!send) {
            send = true;
            var data = null;

            getApplications(ws);
            getAppDetail(ws, appId);

            switch (action) {
                case 0x04:
                    data = stub.buildCounter({
                        appId: appId,
                        counterId: null
                    });
                    break;
                case 0x05:
                    data = stub.buildCounterDetail({
                        appId: appId,
                        processId: 1,
                        counterId: null
                    });
                    break;
                case 0x06:
                    data = stub.buildSend({
                        appId: appId,
                        sendId: 1
                    });
                    break;
                case 0x07:
                    data = stub.buildSendDetail({
                        appId: appId,
                        processId: 1,
                        sendId: null
                    });
                    break;
                case 0xA0:
                    data = stub.buildRestart({
                        appId: appId
                    });
                    break;
                case 0xA1:
                    data = stub.buildAbort({
                        appId: appId
                    });
                    break;
            }
            console.log(data);
            var buffer = new BufferBuilder();
            buffer.appendUInt8(action);
            buffer.appendBuffer(data);
            ws.send(buffer.get(), {binary: true});
        }

    });

    var data = stub.buildLogin(stub.loginData);
    var buffer = new BufferBuilder();
    buffer.appendUInt8(0x01);
    buffer.appendBuffer(data);
    ws.send(buffer.get(), {binary: true});
});*/

