/**
 * Stupid websocket testclient
 *
 * @module ompimon
 * @submodule ompimon-client
 */
var
    BufferBuilder = require("buffer-builder"),
    stub = require("ompimon-protocol/test-client-stub"),
    _ = require("underscore"),
    Parser = require("ompimon-protocol/parser"),
    globals = require("ompimon-protocol/globals"),
    program = require("commander")
;

var action = 0x04;

var appId = process.argv[2];
console.log(appId);


var WebSocket = require('ws');

new TestClient("ws://localhost:8080");


/**
 * @class TestClient
 * @namespace Ompimon.Client
 * @param uri {String} uri for the webservice
 * @constructor
 */
function TestClient(uri) {
    /**
     * URI of the webservice
     * @property uri
     * @type String
     */
    this.uri = uri;

    this.ws = null;

    this.isLoggedIn = false;


    this.init();
}

_.extend(TestClient.prototype, {
    init: function() {
        this.ws = new WebSocket(this.uri);
        this.ws.on('message', _.bind(this.handleMessage, this));
        this.sendLogin();
    },
    send: function(buffer) {
        this.ws.send(buffer, {binary: true});
    },
    handleMessage: function(message) {
        console.log("received:");
        console.log(message);

        var parser = new Parser(message);
        switch(parser.readUInt8()) {
            case 0x02:
                parseApplications(parser);
                break;
            case 0x03:
                parseAppDetail(parser);
                break;
            case 0x05:
                parseCounterDetail(parser);
                break;
            case 0x04:
                parseCounter(parser);
                break;
            case 0x06:
                parseSend(parser);
                break;
            case 0x07:
                parseSendDetail(parser);
                break;
            case 0xA0:
                console.log("Restart successfull");
                break;
            case 0xA1:
                console.log("Abort successfull");
                process.exit();
                break;
        }
    },
    sendLogin: function() {
        var data = stub.buildLogin(stub.loginData);
        var buffer = new BufferBuilder();
        buffer.appendUInt8(0x01);
        buffer.appendBuffer(data);
        this.send(buffer.get());
    }
});





/*
ws.on('open', function() {
    console.log("connected");

    ws.on('message', function(message) {

        if (!send) {
            send = true;
            var data = null;

            getApplications(ws);
            getAppDetail(ws, appId);

            switch (action) {
                case 0x04:
                    data = stub.buildCounter({
                        appId: appId,
                        counterId: null
                    });
                    break;
                case 0x05:
                    data = stub.buildCounterDetail({
                        appId: appId,
                        processId: 1,
                        counterId: null
                    });
                    break;
                case 0x06:
                    data = stub.buildSend({
                        appId: appId,
                        sendId: 1
                    });
                    break;
                case 0x07:
                    data = stub.buildSendDetail({
                        appId: appId,
                        processId: 1,
                        sendId: null
                    });
                    break;
                case 0xA0:
                    data = stub.buildRestart({
                        appId: appId
                    });
                    break;
                case 0xA1:
                    data = stub.buildAbort({
                        appId: appId
                    });
                    break;
            }
            console.log(data);
            var buffer = new BufferBuilder();
            buffer.appendUInt8(action);
            buffer.appendBuffer(data);
            ws.send(buffer.get(), {binary: true});
        }

    });

    var data = stub.buildLogin(stub.loginData);
    var buffer = new BufferBuilder();
    buffer.appendUInt8(0x01);
    buffer.appendBuffer(data);
    ws.send(buffer.get(), {binary: true});
});*/


function parseCounterDetail(parser) {
    var result = [];
    var time = parser.readUInt32();
    var date = new Date(time*1000);
    console.log("received at ", date);
    var length = parser.readUInt16();
    console.log(length);
    for (var i = 0; i < length; i++) {
        result.push({
            timestamp: parser.readUInt32(),
            value: parser.readUInt32()
        });
    }
    console.log(result);
}

function parseCounter(parser) {
    var time = parser.readUInt32();
    var date = new Date(time*1000);
    console.log("received at ", date);
    var length = parser.readUInt32();
    var result = [];
    for (var i = 0; i< length; i++) {
        result.push({
            rank: parser.readUInt32(),
            value: parser.readUInt32()
        });
    }
    console.log(result);
}

function parseApplications(parser) {
    var length = parser.readUInt8();
    var result = [];
    for (var i = 0; i < length; i++) {
        result.push({
            id: parser.readUInt32(),
            name: parser.readString(parser.readUInt32())
        });
    }
    console.log(result);
}

function getApplications(ws) {
    data = stub.buildApplication();
    var buffer = new BufferBuilder();
    buffer.appendUInt8(0x02);
    buffer.appendBuffer(data);
    ws.send(buffer.get(), {binary: true});
}

function parseAppDetail(parser) {
    var result = {
        processes: parser.readUInt32(),
        nodes: parser.readUInt32(),
        ranks: [],
        counters: [],
        sends: [],
        features: {}
    };
    for (var i = 0; i < result.processes; i++) {
        result.ranks.push(parser.readUInt32());
    }
    var counters = parser.readUInt32();
    for (var i = 0; i < counters; i++) {
        result.counters.push(parser.readString(parser.readUInt8()));
    }
    var sends = parser.readUInt32();
    for (var i = 0; i < sends; i++) {
        result.sends.push(parser.readString(parser.readUInt8()));
    }
    var features = parser.readUInt8();
    for (var i = 0; i < features; i++) {
        var name = globals.features[parser.readUInt8()];
        result.features[name] = true;
    }

    console.log(result);

}

function getAppDetail(ws, appId) {
    var data = stub.buildAppDetail({
        appId: appId
    });
    var buffer = new BufferBuilder();
    buffer.appendUInt8(0x03);
    buffer.appendBuffer(data);
    ws.send(buffer.get(), {binary: true});
}

function parseSend(parser) {
    var time = parser.readUInt32();
    var date = new Date(time*1000);
    console.log("received at ", date);
    var length = parser.readUInt16();
    var result = [];
    for (var i = 0; i < length; i++) {
        result.push({
            rank: parser.readUInt32(),
            toRank: parser.readUInt32(),
            size: parser.readUInt64()
        });
    }
    console.log(result);
}

function parseSendDetail(parser) {
    var time = parser.readUInt32();
    var date = new Date(time*1000);
    console.log("received at ", date);

    var length = parser.readUInt16();
    var result = [];
    for (var i = 0; i < length; i++) {
        result.push({
            timestamp: parser.readUInt32(),
            to: parser.readUInt32(),
            value: parser.readUInt64()
        });
    }
    console.log(result);
}
