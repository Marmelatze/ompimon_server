var
    crypto = require("crypto"),
    domain = require('domain'),

    Protocol = require("ompimon-protocol"),
    Client = require("./client"),
    Monitor = require("ompimon-monitor"),
    cluster = require("cluster"),
    numCPUs = require('os').cpus().length
    ;


var start = function() {
    console.log("Started with id " + process.pid);
    global.monitor = new Monitor("client_node", process.pid);

    var protocol = new Protocol();

    var WebSocketServer = require('ws').Server
        , wss = new WebSocketServer({port: 8080});

    /*setInterval(function() {
        var memory = process.memoryUsage();
        console.log("Heap",
            Math.round(memory.heapUsed / 1024 / 1024) + " MB / "+
                Math.round(memory.heapTotal / 1024 / 1024) + " MB"
        );
    }, 1000);*/

    wss.on('connection', function (socket) {
        var d = domain.create();
        d.add(socket);
        d.on('error', function (er) {
            console.error("error", er);
            console.log(er.trace());
            socket.close();
        });

        d.run(function() {
            var id = crypto.createHash('md5').update(crypto.randomBytes(512)).digest('hex');
            var client = new Client(id, socket);
            monitor.addComponent('client', id);

            console.log("client "+client.id+" connected");

            socket.on('message', function (data) {
                console.log(data);
                process.nextTick(function() {
                    protocol.parseClient(client, data);
                });

            });
            socket.on('close', function() {
                monitor.removeComponent('client', id);
                client.quit();
            });
        })

    });

    protocol.on('send', function(client, data) {
        monitor.message('me', 'client:'+client.id, data.readUInt8(0), data);
        client.write(data);
    });
}


exports.start = function() {
    if (numCPUs <= 1) {
        start();

        return;
    }

    if (cluster.isMaster) {
        // Fork workers.
        for (var i = 0; i < numCPUs; i++) {
            cluster.fork();
            console.log("forked");
        }
        cluster.on('exit', function (worker, code, signal) {
            console.log('worker ' + worker.process.pid + ' died');
            cluster.fork();
        });
    } else {
        start();
    }

};
