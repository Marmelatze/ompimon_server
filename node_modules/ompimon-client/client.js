/**
 * @module ompimon
 * @submodule ompimon-client
 */

var
    util = require("util"),
    _ = require("underscore"),
    eventEmitter = require("events").EventEmitter,
    async = require("async"),
    BufferBuilder = require("buffer-builder"),
    Storage = require("ompimon-storage"),
    color = require("bash-color")


    ;


/**
 * Represents a client connected to the server.
 * Maintains one redis connection per client.
 *
 * ## Redis ##
 *
 * A connected client listens to incomming requests via redis publish/subscribe for real time data on the channel `client:app:<appId>`.
 * Messages are transmitted in JSON format.
 *
 * Possible messages on this channel are:
 *
 * **restart**:
 * Will be received, when a finalized app is started again.

     {
        "action": "restart"
     }

 * **finalize**:
 * Will be received, when a app gets finalized

     {
        "action": "finalize"
     }

 * @class Client
 * @namespace Ompimon.Client
 * @param id {Integer} Client id
 * @param socket {Websocket}
 * @extends EventEmitter
 * @constructor
 * @author Florian Pfitzer<pfitzer@w3p.cc>
 */
module.exports = Client;
function Client(id, socket) {
    eventEmitter.call(this);
    this.init(id, socket);
}

util.inherits(Client, eventEmitter);

_.extend(Client.prototype, {
    init: function(id, socket) {
        var self = this;

        /**
         * Id of Client
         * @property id
         * @type Integer
         */
        this.id = id;
        /**
         * Websocket of client
         * @property socket
         * @type Websocket
         */
        this.socket = socket;

        /**
         * Whether this client is authenticated
         * @property authenticated
         * @type boolean
         */
        this.authenticated = false;

        /**
         * Id of the current app
         * @property appId
         * @type Integer
         */
        this.appId = null;

        /**
         * Current action
         * @property action
         * @type Integer
         */
        this.action = null;

        this.log("connected");

        this.redis = Storage.createConnection();

        this.redis.on('subscribe', function (channel) {
            console.log("subscribed to " + channel);
        });

        this.redis.on('message', function (channel, message) {
            if (channel !== "client:app:" + self.appId) {
                return;
            }
            self.log("recevied from cluster " + color.black(message));
            message = JSON.parse(message);
            switch (message.action) {
                case 'finalize':
                    this.log("received finalize");
                    var buffer = new BufferBuilder();
                    buffer.appendUInt8(0xA2);
                    buffer.appendUInt32BE(this.appId);
                    this.write(buffer.get());

                    break;
                case 'restart':
                    this.log("restart received");
                    var buffer = new BufferBuilder();
                    buffer.appendUInt8(0xA3);
                    buffer.appendUInt32BE(this.appId);
                    this.write(buffer.get());

                    break;
                default:
                    process.nextTick(function() {
                        self.emit('message', message);
                    });
            }

        }.bind(this));
    },


    /**
     * receive updates for this app.
     * Will fire {{#crossLink "Ompimon.Client.Client/select_app:event"}}{{/crossLink}} and {{#crossLink "Ompimon.Client.Client/change:event"}}{{/crossLink}}
     *
     * When the app is already finalized, we send `0xA2 *AppId*` to the client.
     * @method selectApp
     * @param appId {Integer}
     */
    selectApp: function (appId) {
        if (appId == this.appId) {
            return;
        }
        this.log("selected app " + appId);

        this.redis.unsubscribe('client:app:' + this.appId); // unsubscribe from old
        this.appId = appId;
        this.redis.subscribe('client:app:' + this.appId);

        this.removeAllListeners('message');

        this.emit('select_app', appId);
        this.emit('change');

        Storage.isFinalize(this.appId, function(err, finalize){
            if (finalize == 'true') {
                var buffer = new BufferBuilder();
                buffer.appendUInt8(0xA2);
                buffer.appendUInt32BE(this.appId);
                this.write(buffer.get());
            }
        }.bind(this));
    },



    /**
     * Select current action
     * Will fire {{#crossLink "Ompimon.Client.Client/select_action:event"}}{{/crossLink}} event and {{#crossLink "Ompimon.Client.Client/change:event"}}{{/crossLink}} event.
     *
     * @method selectAction
     * @param action {Integer}
     */
    selectAction: function (action) {
        this.log("selected action " + action);
        this.action = action;
        this.removeAllListeners('message');
        this.emit('select_action', action);
        this.emit('change');
    },

    /**
     * Quit client, removes all event listeners.
     * Will fire {{#crossLink "Ompimon.Client.Client/quit:event"}}{{/crossLink}} and {{#crossLink "Ompimon.Client.Client/change:event"}}{{/crossLink}} event.
     *
     * @method quit
     */
    quit: function () {
        this.log("quit");
        this.emit('quit');
        this.emit('change');
        this.removeAllListeners('message');
        this.removeAllListeners('select_app');
        this.removeAllListeners('select_action');
        this.redis.quit();
    },

    /**
     * Write a buffer to the client.
     *
     * @method write
     * @param message {Buffer}
     */
    write: function (message) {
        var self = this;
        if (null !== this.socket) {
            this.socket.send(message, {binary: true}, function(err) {
                if (err) {
                    console.log(err);
                    self.quit();
                }
            });
        }
    },
    /**
     * write pretty log message
     *
     * @method log
     * @param message
     */
    log: function (message) {
        var msg = "";
        for (var i=0; i < arguments.length; i++) {
            if (typeof arguments[i] != 'string') {
                msg += util.inspect(arguments[i]) + "\n";
            } else {
                msg += arguments[i] + "\n";
            }
        }

        console.log(color.green("[" + this.id + "]") + ": " + msg.substr(0, msg.length-1));
    },

    /**
     * Fired when a message from pub/sub is received
     * @event message
     * @param message {Object}
     */
    onMessage: null,

    /**
     * fired when an app is selected
     * @event select_app
     * @param appId {Integer}
     */
    onSelectApp: null,

    /**
     * fired when an action is executed
     * @event select_action
     * @param action {Integer}
     */
    onSelectAction: null,

    /**
     * Will be fired if a client quits.
     * @event quit
     */
    onQuit: null,

    /**
     * Will be fired if client changed his state.
     * Can be fired on selecting another app, action or quit.
     * @event change
     */
    onChange: null
});

